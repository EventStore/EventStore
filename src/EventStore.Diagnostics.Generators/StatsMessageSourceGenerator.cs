using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

// for speed and simplicity this does all its generation based on the syntax tree and not on the semantic model
//qqqqq this will need to be accessible to plugins, so would need to move it to the plugins nuget package
// and change the way that we reference it
// https://github.com/dotnet/roslyn/blob/main/docs/features/source-generators.cookbook.md#package-a-generator-as-a-nuget-package
// https://github.com/dotnet/roslyn/blob/main/docs/features/source-generators.cookbook.md#unit-testing-of-generators
// when testing, consider nested classes, nested namespaces, two namespaces in one compilation unit
// public and private messages, messages in a type hierarchy (with the attribute at multiple levels)
// attribute specified with namespace qualification
//qq todo: nuget package
//qq we could improve the compiler error messages if you e.g. apply this attribute to something that isn't a message
//qq todo: make it issue a warning if decorating an enum whose first member is not `None`
// maybe issue warnings if the enums are not suitable numbered too
//qq or warning if you apply in a non partial class
//qq spot duplicate names at runtime?
//qq convert the exceptions in here into proper diagnostic outputs
namespace EventStore.Diagnostics.Generators {
	[Generator]
	public class StatsMessageSourceGenerator : ISourceGenerator {
		GeneratorExecutionContext _context;

		public void Initialize(GeneratorInitializationContext context) {
			context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
		}

		public void Execute(GeneratorExecutionContext context) {
			try {
				ExecuteImpl(context);
			} catch (Exception ex) {
				// tooling only shows the first line of the exception
				var stack = ex.StackTrace.Replace("\r\n", " >> ");
				throw new Exception($"{ex.Message}. Stack: {stack}", ex);
			}
		}

		void ExecuteImpl(GeneratorExecutionContext context) {
			_context = context;

			if (context.SyntaxReceiver is not SyntaxReceiver syntaxReceiver) {
				throw new Exception("Unexpected syntax receiver");
			}

			var roots = new HashSet<CompilationUnitSyntax>();
			var members = new MemberTree();
			foreach (var candidate in syntaxReceiver.Candidates) {
				RegisterMember(candidate, members, roots);
			}

			foreach (var node in roots) {
				context.AddSource(GenFileName(node), GenSource(node, members));
			}
		}

		string GenSource(CompilationUnitSyntax node, MemberTree members) => $@"
// autogenerated

using System.Diagnostics.Tracing;
using System.Threading;
using EventStore.Core.Diagnostics; //qq consider if this gets renamed

#pragma warning disable CS0108 // Member hides inherited member; missing new keyword
{
	Transform(node, members)
		.NormalizeWhitespace()
		.ToFullString()
}
";

		string GenFileName(SyntaxNode node) {
			var path = node.SyntaxTree.FilePath;
			var fileName = Path.GetFileNameWithoutExtension(path);
			return $"{fileName}-{(uint)path.GetHashCode()}.g.cs";
		}

		void RegisterMember(MemberDeclarationSyntax member, MemberTree members, HashSet<CompilationUnitSyntax> roots) {
			if (members.TryGetValue(member.Parent, out var siblings)) {
				siblings.Add(member);
			} else {
				members[member.Parent] = new HashSet<MemberDeclarationSyntax> { member };
				if (member.Parent is MemberDeclarationSyntax mds) {
					RegisterMember(mds, members, roots);
				} else if (member.Parent is CompilationUnitSyntax cus) {
					roots.Add(cus);
				} else {
					throw new Exception($"Unexpected parent: \"{member.Parent.Kind()}\"");
				}
			}
		}

		CompilationUnitSyntax Transform(CompilationUnitSyntax node, MemberTree members) =>
			SyntaxFactory
				.CompilationUnit()
				.AddMembers(TransformChildren(node, members));

		MemberDeclarationSyntax[] TransformChildren(SyntaxNode node, MemberTree members) =>
			members.TryGetValue(node, out var children)
				? children
					.Select(x => Transform(x, members))
					.ToArray()
				: Array.Empty<MemberDeclarationSyntax>();

		MemberDeclarationSyntax Transform(MemberDeclarationSyntax node, MemberTree members) =>
			node switch {
				NamespaceDeclarationSyntax x => Transform(x, members),
				FileScopedNamespaceDeclarationSyntax x => Transform(x, members),
				ClassDeclarationSyntax x => Transform(x, members),
				EnumDeclarationSyntax x => Transform(x, members),
				_ => throw new Exception($"Unexpected MemberDeclarationSyntax syntax: \"{node.Kind()}\"")
			};

		NamespaceDeclarationSyntax Transform(NamespaceDeclarationSyntax node, MemberTree members) =>
			SyntaxFactory
				.NamespaceDeclaration(
					name: node.Name,
					externs: default,
					usings: node.Usings,
					members: default)
				.AddMembers(TransformChildren(node, members));

		FileScopedNamespaceDeclarationSyntax Transform(FileScopedNamespaceDeclarationSyntax node, MemberTree members) =>
			SyntaxFactory
				.FileScopedNamespaceDeclaration(
					attributeLists: default,
					modifiers: default,
					name: node.Name,
					externs: default,
					usings: node.Usings,
					members: default)
				.AddMembers(TransformChildren(node, members));

		ClassDeclarationSyntax Transform(ClassDeclarationSyntax node, MemberTree members) =>
			SyntaxFactory
				.ClassDeclaration(
					attributeLists: default,
					modifiers: node.Modifiers,
					identifier: node.Identifier,
					typeParameterList: node.TypeParameterList,
					baseList: default,
					constraintClauses: default,
					members: default)
				.AddMembers(TransformChildren(node, members))
				.AddStatsMembers(_context, node)
				.WithoutTrivia();

		MemberDeclarationSyntax Transform(EnumDeclarationSyntax node, MemberTree members) {
			if (!node.TryGetStatsGroupAttribute(out var statsGroupAttribute)) {
				throw new Exception("EnumDeclarationSyntax expected to have StatsGroupAttribute but does not");
			}

			var hyphenCaseName = statsGroupAttribute.ArgumentList.Arguments[0].ToString().RemoveEnclosingQuotes();


			// the enum name is passed to the StateMessage attribute
			// so it is a good way to coordinate whatever the two generators need to agree upon. i.e.
			//   - the EventSource class name
			//   but these are all implementation details that are not exposed to the metrics collectors.
			// i think the enum name should drive the EventSource name
			var enumName = node.Identifier.Text;
			var eventSourceClass = NamingStrategy.EventSourceClassName(enumName);

			//qqqqqqq put this nearer the other generated code it is closely related
			// the current problem may be coming from the fact that we are attaching the generated class rather than the generic class on to the message classes
			var result = SyntaxFactory.ParseMemberDeclaration(@$"
[EventSource(Name = ""eventstore-experiments-{hyphenCaseName}"")]
public class {eventSourceClass}: MyEventSource<{enumName}> {{
	public static {eventSourceClass} Log {{ get; }} = new {eventSourceClass}();

	//qqqq what if we want to change the version later, does that make any sense for the plugins?
	//   say if we added an argument, i guess we would have a different helper overload for that and the plugin would adjust the version when
	//   it  started calling it
	//qq for now this method is only present for the manifest generation, we dont actually call it, but perhaps we should.
	[Event(MessageProcessedEventId, Version = 0, Level = EventLevel.Informational, Message = ""{hyphenCaseName} "" + TheLogString)]
	public void MessageProcessed(
		QueueId queueId,
		{enumName} messageTypeId,
		float queueMicroseconds,
		float processingMicroseconds) {{

//		MessageProcessed(queueId, (int)messageTypeId, queueMicroseconds, processingMicroseconds);
	}}
}}
");
			if (result is null) {
				throw new Exception("Failed to parse generated eventsource");
			}

			return result;
		}


		class SyntaxReceiver : ISyntaxReceiver {
			public List<MemberDeclarationSyntax> Candidates { get; } = new();

			public void OnVisitSyntaxNode(SyntaxNode syntaxNode) {
				if (syntaxNode is ClassDeclarationSyntax classDeclarationSyntax &&
					(classDeclarationSyntax.TryGetStatsAttribute(out _) ||
					 classDeclarationSyntax.TryGetRootMessageAttribute(out _))) {

					Candidates.Add(classDeclarationSyntax);

				} else if (syntaxNode is EnumDeclarationSyntax enumDeclarationSyntax &&
					enumDeclarationSyntax.TryGetStatsGroupAttribute(out _)) {

					Candidates.Add(enumDeclarationSyntax);
				}
			}
		}
		
		class MemberTree : Dictionary<SyntaxNode, HashSet<MemberDeclarationSyntax>> {
		}
	}

	static class NamingStrategy {
		public static string EventSourceClassName(string enumName) => $"{enumName}Source";
	}

	static class ContextExtensions {
		static readonly DiagnosticDescriptor MissingEnumMemberWarning = new(
			id: "ESGEN001",
			title: "Incorrect StatsMessage attribute usage",
			messageFormat: "Missing enumMember on an non-abstract class",
			category: "EventStore.Messaging",
			DiagnosticSeverity.Error,
			isEnabledByDefault: true);

		static readonly DiagnosticDescriptor ExtraEnumMemberWarning = new(
			id: "ESGEN002",
			title: "Incorrect StatsMessage attribute usage",
			messageFormat: "Found enumMember on an abstract class",
			category: "EventStore.Messaging",
			DiagnosticSeverity.Error,
			isEnabledByDefault: true);

		public static void ReportMissingEnumMember(this GeneratorExecutionContext context, ClassDeclarationSyntax node) => 
			context.ReportDiagnostic(Diagnostic.Create(MissingEnumMemberWarning, node.GetLocation()));

		public static void ReportExtraEnumMember(this GeneratorExecutionContext context, ClassDeclarationSyntax node) =>
			context.ReportDiagnostic(Diagnostic.Create(ExtraEnumMemberWarning, node.GetLocation()));

	}

	static class ClassDeclarationSyntaxExtensions {
		enum Kind {
			None,
			Root,
			Abstract,
			Normal,
		};

		static (Kind, AttributeSyntax) GetStatsAttribute(
			GeneratorExecutionContext context,
			ClassDeclarationSyntax node) {

			var isAbstract = node.Modifiers.Any(SyntaxKind.AbstractKeyword);

			if (node.TryGetRootMessageAttribute(out var attributeSyntax)) {
				return (Kind.Root, attributeSyntax);
			}

			if (node.TryGetStatsAttribute(out attributeSyntax)) {
				var args = attributeSyntax.ArgumentList;
				if (args is null || args.Arguments.Count == 0) {
					if (!isAbstract) {
						context.ReportMissingEnumMember(node);
					}
					return (Kind.Abstract, attributeSyntax);
				} else {
					if (isAbstract) {
						context.ReportExtraEnumMember(node);
					}
					return (Kind.Normal, attributeSyntax);
				}
			}

			return (Kind.None, default);
		}

		public static ClassDeclarationSyntax AddStatsMembers(
			this ClassDeclarationSyntax node,
			GeneratorExecutionContext context,
			ClassDeclarationSyntax originalNode) =>
			
			GetStatsAttribute(context, originalNode) switch {
				(Kind.None, _) => node,
				(Kind.Root, _) => node.AddRootStatsMembers(),
				(Kind.Abstract, _) => node.AddAbstractStatsMembers(),
				(Kind.Normal, var attribute) => node.AddNormalStatsMembers(attribute),
				_ => throw new InvalidOperationException(),
			};

		public static ClassDeclarationSyntax AddRootStatsMembers(this ClassDeclarationSyntax node) =>
			node.AddMembers(CreateDynamicMessageId())
				.AddMembers(RegisterDynamicMessageId(isRoot: true))
				.AddMembers(CreateStatsId());

		public static ClassDeclarationSyntax AddAbstractStatsMembers(this ClassDeclarationSyntax node) =>
			node.AddMembers(RegisterDynamicMessageId(isRoot: false));

		public static ClassDeclarationSyntax AddNormalStatsMembers(
			this ClassDeclarationSyntax node,
			AttributeSyntax attribute) {

			var args = attribute.ArgumentList;
			if (args is null)
				throw new Exception($"Unexpected null attibute argument list for {node.Identifier}");

			if (args.Arguments.Count < 1)
				throw new Exception($"Missing arguments for {node.Identifier}");

			var enumValue = args.Arguments[0].ToString();
			var enumType = enumValue.Substring(0, enumValue.LastIndexOf('.'));
			var eventSourceClass = NamingStrategy.EventSourceClassName(enumType);

			return node
				.AddMembers(RegisterDynamicMessageId(isRoot: false))
				.AddMembers(RegisterStatsId(enumValue, eventSourceClass));
		}

		private static string[] CreateDynamicMessageId() => new[] {
			"private static int _nextMsgId = -1;",
			"protected static ref int NextMsgId => ref _nextMsgId;"
		};

		private static string[] RegisterDynamicMessageId(bool isRoot) {
			var virtualOrOverride = isRoot ? "virtual" : "override";
			return new[] {
				//qq some of these string literals should probably be nameofs
				$"private static readonly int TypeId = Interlocked.Increment(ref NextMsgId);",
				$"public {virtualOrOverride} int MsgTypeId => TypeId;",
			};
		}

		private static string[] CreateStatsId() => new string[] {
			"public abstract int MessageTypeId { get; }",
			"public abstract int StatsId { get; }",
			"public abstract MyEventSource EventSource { get; }",
		};

		private static string[] RegisterStatsId(string enumValue, string eventSourceClass) => new[] {
			//qq some of these string literals should probably be nameofs
			//qq how do the plugins currently define messages, persumably they would need to
			// reference the core project somehow
			//qq is Unsafe.As faster than (int) cast?
			$"public static int MessageTypeIdStatic {{ get; }} = (int){enumValue};",
			$"public static int StatsIdStatic {{ get; set; }} = (int){enumValue};",
			$"public static MyEventSource EventSourceStatic {{ get; }} = {eventSourceClass}.Log;",
			$"public override int MessageTypeId => MessageTypeIdStatic;",
			$"public override int StatsId => StatsIdStatic;",
			$"public override MyEventSource EventSource => EventSourceStatic;",
		};

		public static ClassDeclarationSyntax AddMembers(this ClassDeclarationSyntax node, params string[] members) {
			var parsed = members
				.Select(static x => SyntaxFactory.ParseMemberDeclaration(x))
				.ToArray();

			for (int i = 0; i < parsed.Length; i++) {
				if (parsed[i] is null)
					throw new Exception($"Could not parse member: {members[i]}");
			}

			return node.AddMembers(parsed);
		}

		//qq hmm!
		public static bool TryGetStatsAttribute(this ClassDeclarationSyntax node, out AttributeSyntax attributeSyntax) =>
			node.TryGetAttribute<StatsMessageAttribute>(minArgCount: 0, maxArgCount: 1, attributeSyntax: out attributeSyntax);

		//qq hmm!
		public static bool TryGetRootMessageAttribute(this ClassDeclarationSyntax node, out AttributeSyntax attributeSyntax) =>
			node.TryGetAttribute<RootMessageAttribute>(minArgCount: 0, maxArgCount: 0, attributeSyntax: out attributeSyntax);
	}

	public static class EnumDeclarationSyntaxExtensions {
		//qq hmm!
		public static bool TryGetStatsGroupAttribute(this EnumDeclarationSyntax node, out AttributeSyntax attributeSyntax) =>
			node.TryGetAttribute<StatsGroupAttribute>(minArgCount: 1, maxArgCount: 1, attributeSyntax: out attributeSyntax);
	}

	static class SyntaxExtensions {
		public static bool TryGetAttribute<T>(
			this MemberDeclarationSyntax node,
			int minArgCount,
			int maxArgCount,
			out AttributeSyntax attributeSyntax) {

			var name = typeof(T).Name;
			name = name.Substring(0, name.LastIndexOf("Attribute"));

			foreach (var attributeList in node.AttributeLists) {
				foreach (var candidate in attributeList.Attributes) {
					var actualArgCount = candidate.ArgumentList?.Arguments.Count ?? 0;
					if (candidate.Name.ToString() == name &&
						actualArgCount >= minArgCount &&
						actualArgCount <= maxArgCount) {

						attributeSyntax = candidate;
						return true;
					}
				}
			}

			attributeSyntax = default;
			return false;
		}
	}

	public static class StringExtensions {
		public static string RemoveEnclosingQuotes(this string x) => x.Substring(1, x.Length - 2);
	}
}
